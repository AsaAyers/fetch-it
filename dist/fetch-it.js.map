{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///fetch-it.js","webpack:///webpack/bootstrap 18e20dda084afeeea939","webpack:///./src/fetch-it.js","webpack:///./~/es6-promise/dist/es6-promise.js","webpack:///./~/process/browser.js","webpack:///(webpack)/buildin/module.js","webpack:///(webpack)/buildin/amd-define.js","webpack:///./~/whatwg-fetch/fetch.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_toConsumableArray","arr","Array","isArray","i","arr2","length","from","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","DEFAULT_CONFIG","FetchIt","config","middlewares","url","options","method","data","window","Request","defaultMethod","body","assign","Blob","FormData","JSON","stringify","urlOrRequest","request","undefined","_len","arguments","_key","_createRequest","apply","concat","promise","Promise","resolve","chain","fetch","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","reverse","Symbol","iterator","next","done","middleware","unshift","requestError","push","response","responseError","err","then","shift","_middlewares","_request","jsonMiddleware","res","json","e","FetchItFactory","addMiddlewares","clearMiddlewares","_instance","_instance2","get","_instance3","post","_instance4","patch","_instance5","put","_instance6","_instance7","head","__WEBPACK_AMD_DEFINE_RESULT__","process","global","lib$es6$promise$utils$$objectOrFunction","x","lib$es6$promise$utils$$isFunction","lib$es6$promise$asap$$setScheduler","scheduleFn","lib$es6$promise$asap$$customSchedulerFn","lib$es6$promise$asap$$setAsap","asapFn","lib$es6$promise$asap$$asap","lib$es6$promise$asap$$useNextTick","nextTick","lib$es6$promise$asap$$flush","lib$es6$promise$asap$$useVertxTimer","lib$es6$promise$asap$$vertxNext","lib$es6$promise$asap$$useMutationObserver","iterations","observer","lib$es6$promise$asap$$BrowserMutationObserver","node","document","createTextNode","observe","characterData","lib$es6$promise$asap$$useMessageChannel","channel","MessageChannel","port1","onmessage","port2","postMessage","lib$es6$promise$asap$$useSetTimeout","setTimeout","lib$es6$promise$asap$$len","callback","lib$es6$promise$asap$$queue","arg","lib$es6$promise$asap$$attemptVertx","vertx","runOnLoop","runOnContext","lib$es6$promise$then$$then","onFulfillment","onRejection","parent","state","_state","lib$es6$promise$$internal$$FULFILLED","lib$es6$promise$$internal$$REJECTED","child","constructor","lib$es6$promise$$internal$$noop","result","_result","lib$es6$promise$$internal$$invokeCallback","lib$es6$promise$$internal$$subscribe","lib$es6$promise$promise$resolve$$resolve","object","lib$es6$promise$$internal$$resolve","lib$es6$promise$$internal$$selfFulfillment","lib$es6$promise$$internal$$cannotReturnOwn","lib$es6$promise$$internal$$getThen","error","lib$es6$promise$$internal$$GET_THEN_ERROR","lib$es6$promise$$internal$$tryThen","fulfillmentHandler","rejectionHandler","lib$es6$promise$$internal$$handleForeignThenable","thenable","sealed","lib$es6$promise$$internal$$fulfill","reason","lib$es6$promise$$internal$$reject","_label","lib$es6$promise$$internal$$handleOwnThenable","lib$es6$promise$$internal$$handleMaybeThenable","maybeThenable","lib$es6$promise$then$$default","lib$es6$promise$promise$resolve$$default","lib$es6$promise$$internal$$publishRejection","_onerror","lib$es6$promise$$internal$$publish","lib$es6$promise$$internal$$PENDING","_subscribers","subscribers","settled","detail","lib$es6$promise$$internal$$ErrorObject","lib$es6$promise$$internal$$tryCatch","lib$es6$promise$$internal$$TRY_CATCH_ERROR","succeeded","failed","hasCallback","lib$es6$promise$$internal$$initializePromise","resolver","lib$es6$promise$promise$all$$all","entries","lib$es6$promise$enumerator$$default","lib$es6$promise$promise$race$$race","lib$es6$promise$utils$$isArray","lib$es6$promise$promise$reject$$reject","lib$es6$promise$promise$$needsResolver","lib$es6$promise$promise$$needsNew","lib$es6$promise$promise$$Promise","_id","lib$es6$promise$promise$$counter","lib$es6$promise$enumerator$$Enumerator","input","_instanceConstructor","_input","_remaining","_enumerate","_validationError","lib$es6$promise$polyfill$$polyfill","local","self","Function","Error","P","toString","cast","lib$es6$promise$promise$$default","lib$es6$promise$utils$$_isArray","lib$es6$promise$asap$$scheduleFlush","lib$es6$promise$asap$$browserWindow","lib$es6$promise$asap$$browserGlobal","MutationObserver","WebKitMutationObserver","lib$es6$promise$asap$$isNode","lib$es6$promise$asap$$isWorker","Uint8ClampedArray","importScripts","lib$es6$promise$promise$all$$default","lib$es6$promise$promise$race$$default","lib$es6$promise$promise$reject$$default","all","race","reject","_setScheduler","_setAsap","_asap","catch","_eachEntry","entry","_settledAt","_willSettleAt","enumerator","lib$es6$promise$polyfill$$default","lib$es6$promise$umd$$ES6Promise","polyfill","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","len","run","clearTimeout","Item","fun","array","noop","args","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","name","cwd","chdir","dir","umask","webpackPolyfill","deprecate","paths","children","normalizeName","String","test","toLowerCase","normalizeValue","Headers","headers","map","forEach","append","getOwnPropertyNames","consumed","bodyUsed","fileReaderReady","reader","onload","onerror","readBlobAsArrayBuffer","blob","FileReader","readAsArrayBuffer","readBlobAsText","readAsText","Body","_initBody","_bodyInit","_bodyText","support","isPrototypeOf","_bodyBlob","formData","_bodyFormData","arrayBuffer","ArrayBuffer","set","type","rejected","text","decode","parse","normalizeMethod","upcased","toUpperCase","methods","indexOf","credentials","mode","referrer","form","trim","split","bytes","replace","join","decodeURIComponent","xhr","pairs","getAllResponseHeaders","header","Response","bodyInit","status","ok","statusText","list","values","getAll","has","hasOwnProperty","thisArg","clone","redirectStatuses","redirect","RangeError","location","init","responseURL","getResponseHeader","XMLHttpRequest","responseText","open","withCredentials","responseType","setRequestHeader","send"],"mappings":"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","file":"fetch-it.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fetchIt\"] = factory();\n\telse\n\t\troot[\"fetchIt\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fetchIt\"] = factory();\n\telse\n\t\troot[\"fetchIt\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\t__webpack_require__(1);\n\t\n\t__webpack_require__(6);\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar DEFAULT_CONFIG = {};\n\t\n\tvar FetchIt = function () {\n\t  function FetchIt(config) {\n\t    _classCallCheck(this, FetchIt);\n\t\n\t    this.config = config || DEFAULT_CONFIG;\n\t    this.middlewares = [];\n\t  }\n\t\n\t  _createClass(FetchIt, [{\n\t    key: '_createRequest',\n\t    value: function _createRequest(url, options, method, data) {\n\t      if (!options && !method && !data) {\n\t        return new window.Request(url);\n\t      }\n\t\n\t      var defaultMethod = !data && !!options && !options.body ? 'GET' : 'POST';\n\t\n\t      options = Object.assign({}, this.config, options || {});\n\t      options.method = method || options.method || defaultMethod;\n\t      if (!!data) {\n\t        if (data instanceof window.Blob || data instanceof window.FormData || typeof data === 'string') {\n\t          options.body = data;\n\t        } else {\n\t          options.body = window.JSON.stringify(data);\n\t        }\n\t      }\n\t\n\t      return new window.Request(url, options);\n\t    }\n\t  }, {\n\t    key: '_request',\n\t    value: function _request(urlOrRequest) {\n\t      var request = undefined;\n\t      if (urlOrRequest instanceof window.Request) {\n\t        request = urlOrRequest;\n\t      } else {\n\t        for (var _len = arguments.length, options = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t          options[_key - 1] = arguments[_key];\n\t        }\n\t\n\t        request = this._createRequest.apply(this, [urlOrRequest].concat(options));\n\t      }\n\t\n\t      var promise = window.Promise.resolve(request);\n\t      var chain = [window.fetch, undefined];\n\t\n\t      var _iteratorNormalCompletion = true;\n\t      var _didIteratorError = false;\n\t      var _iteratorError = undefined;\n\t\n\t      try {\n\t        for (var _iterator = this.middlewares.reverse()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t          var middleware = _step.value;\n\t\n\t          chain.unshift(middleware.request, middleware.requestError);\n\t          chain.push(middleware.response, middleware.responseError);\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError = true;\n\t        _iteratorError = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion && _iterator.return) {\n\t            _iterator.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError) {\n\t            throw _iteratorError;\n\t          }\n\t        }\n\t      }\n\t\n\t      while (!!chain.length) {\n\t        promise = promise.then(chain.shift(), chain.shift());\n\t      }\n\t\n\t      return promise;\n\t    }\n\t  }, {\n\t    key: 'addMiddlewares',\n\t    value: function addMiddlewares(middlewares) {\n\t      var _middlewares;\n\t\n\t      (_middlewares = this.middlewares).push.apply(_middlewares, _toConsumableArray(middlewares));\n\t    }\n\t  }, {\n\t    key: 'clearMiddlewares',\n\t    value: function clearMiddlewares() {\n\t      this.middlewares = [];\n\t    }\n\t  }, {\n\t    key: 'fetch',\n\t    value: function fetch(url, options) {\n\t      return this._request(url, options);\n\t    }\n\t  }, {\n\t    key: 'get',\n\t    value: function get(url, options) {\n\t      return this._request(url, options, 'GET');\n\t    }\n\t  }, {\n\t    key: 'post',\n\t    value: function post(url, data, options) {\n\t      return this._request(url, options, 'POST', data);\n\t    }\n\t  }, {\n\t    key: 'patch',\n\t    value: function patch(url, data, options) {\n\t      return this._request(url, options, 'PATCH', data);\n\t    }\n\t  }, {\n\t    key: 'put',\n\t    value: function put(url, data, options) {\n\t      return this._request(url, options, 'PUT', data);\n\t    }\n\t  }, {\n\t    key: 'delete',\n\t    value: function _delete(url, options) {\n\t      return this._request(url, options, 'DELETE');\n\t    }\n\t  }, {\n\t    key: 'head',\n\t    value: function head(url, options) {\n\t      return this._request(url, options, 'HEAD');\n\t    }\n\t  }]);\n\t\n\t  return FetchIt;\n\t}();\n\t\n\tvar jsonMiddleware = {\n\t  response: function response(res) {\n\t    return res.json().catch(function (e) {\n\t      return e;\n\t    });\n\t  }\n\t};\n\t\n\tvar FetchItFactory = function () {\n\t  function FetchItFactory() {\n\t    _classCallCheck(this, FetchItFactory);\n\t\n\t    this.instance = new FetchIt();\n\t    this.middleware = {\n\t      jsonMiddleware: jsonMiddleware\n\t    };\n\t  }\n\t\n\t  _createClass(FetchItFactory, [{\n\t    key: 'create',\n\t    value: function create(config) {\n\t      return new FetchIt(config);\n\t    }\n\t  }, {\n\t    key: 'addMiddlewares',\n\t    value: function addMiddlewares(middlewares) {\n\t      this.instance.addMiddlewares(middlewares);\n\t    }\n\t  }, {\n\t    key: 'clearMiddlewares',\n\t    value: function clearMiddlewares() {\n\t      this.instance.clearMiddlewares();\n\t    }\n\t  }, {\n\t    key: 'fetch',\n\t    value: function fetch() {\n\t      var _instance;\n\t\n\t      return (_instance = this.instance).fetch.apply(_instance, arguments);\n\t    }\n\t  }, {\n\t    key: 'get',\n\t    value: function get() {\n\t      var _instance2;\n\t\n\t      return (_instance2 = this.instance).get.apply(_instance2, arguments);\n\t    }\n\t  }, {\n\t    key: 'post',\n\t    value: function post() {\n\t      var _instance3;\n\t\n\t      return (_instance3 = this.instance).post.apply(_instance3, arguments);\n\t    }\n\t  }, {\n\t    key: 'patch',\n\t    value: function patch() {\n\t      var _instance4;\n\t\n\t      return (_instance4 = this.instance).patch.apply(_instance4, arguments);\n\t    }\n\t  }, {\n\t    key: 'put',\n\t    value: function put() {\n\t      var _instance5;\n\t\n\t      return (_instance5 = this.instance).put.apply(_instance5, arguments);\n\t    }\n\t  }, {\n\t    key: 'delete',\n\t    value: function _delete() {\n\t      var _instance6;\n\t\n\t      return (_instance6 = this.instance).delete.apply(_instance6, arguments);\n\t    }\n\t  }, {\n\t    key: 'head',\n\t    value: function head() {\n\t      var _instance7;\n\t\n\t      return (_instance7 = this.instance).head.apply(_instance7, arguments);\n\t    }\n\t  }]);\n\t\n\t  return FetchItFactory;\n\t}();\n\t\n\texports.default = new FetchItFactory();\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, global, module) {/*!\n\t * @overview es6-promise - a tiny implementation of Promises/A+.\n\t * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n\t * @license   Licensed under MIT license\n\t *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n\t * @version   3.1.2\n\t */\n\t\n\t(function() {\n\t    \"use strict\";\n\t    function lib$es6$promise$utils$$objectOrFunction(x) {\n\t      return typeof x === 'function' || (typeof x === 'object' && x !== null);\n\t    }\n\t\n\t    function lib$es6$promise$utils$$isFunction(x) {\n\t      return typeof x === 'function';\n\t    }\n\t\n\t    function lib$es6$promise$utils$$isMaybeThenable(x) {\n\t      return typeof x === 'object' && x !== null;\n\t    }\n\t\n\t    var lib$es6$promise$utils$$_isArray;\n\t    if (!Array.isArray) {\n\t      lib$es6$promise$utils$$_isArray = function (x) {\n\t        return Object.prototype.toString.call(x) === '[object Array]';\n\t      };\n\t    } else {\n\t      lib$es6$promise$utils$$_isArray = Array.isArray;\n\t    }\n\t\n\t    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\n\t    var lib$es6$promise$asap$$len = 0;\n\t    var lib$es6$promise$asap$$vertxNext;\n\t    var lib$es6$promise$asap$$customSchedulerFn;\n\t\n\t    var lib$es6$promise$asap$$asap = function asap(callback, arg) {\n\t      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\n\t      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\n\t      lib$es6$promise$asap$$len += 2;\n\t      if (lib$es6$promise$asap$$len === 2) {\n\t        // If len is 2, that means that we need to schedule an async flush.\n\t        // If additional callbacks are queued before the queue is flushed, they\n\t        // will be processed by this flush that we are scheduling.\n\t        if (lib$es6$promise$asap$$customSchedulerFn) {\n\t          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\n\t        } else {\n\t          lib$es6$promise$asap$$scheduleFlush();\n\t        }\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$asap$$setScheduler(scheduleFn) {\n\t      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\n\t    }\n\t\n\t    function lib$es6$promise$asap$$setAsap(asapFn) {\n\t      lib$es6$promise$asap$$asap = asapFn;\n\t    }\n\t\n\t    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;\n\t    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\n\t    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\n\t    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\t\n\t    // test for web worker but not in IE10\n\t    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n\t      typeof importScripts !== 'undefined' &&\n\t      typeof MessageChannel !== 'undefined';\n\t\n\t    // node\n\t    function lib$es6$promise$asap$$useNextTick() {\n\t      // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n\t      // see https://github.com/cujojs/when/issues/410 for details\n\t      return function() {\n\t        process.nextTick(lib$es6$promise$asap$$flush);\n\t      };\n\t    }\n\t\n\t    // vertx\n\t    function lib$es6$promise$asap$$useVertxTimer() {\n\t      return function() {\n\t        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\n\t      };\n\t    }\n\t\n\t    function lib$es6$promise$asap$$useMutationObserver() {\n\t      var iterations = 0;\n\t      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\n\t      var node = document.createTextNode('');\n\t      observer.observe(node, { characterData: true });\n\t\n\t      return function() {\n\t        node.data = (iterations = ++iterations % 2);\n\t      };\n\t    }\n\t\n\t    // web worker\n\t    function lib$es6$promise$asap$$useMessageChannel() {\n\t      var channel = new MessageChannel();\n\t      channel.port1.onmessage = lib$es6$promise$asap$$flush;\n\t      return function () {\n\t        channel.port2.postMessage(0);\n\t      };\n\t    }\n\t\n\t    function lib$es6$promise$asap$$useSetTimeout() {\n\t      return function() {\n\t        setTimeout(lib$es6$promise$asap$$flush, 1);\n\t      };\n\t    }\n\t\n\t    var lib$es6$promise$asap$$queue = new Array(1000);\n\t    function lib$es6$promise$asap$$flush() {\n\t      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {\n\t        var callback = lib$es6$promise$asap$$queue[i];\n\t        var arg = lib$es6$promise$asap$$queue[i+1];\n\t\n\t        callback(arg);\n\t\n\t        lib$es6$promise$asap$$queue[i] = undefined;\n\t        lib$es6$promise$asap$$queue[i+1] = undefined;\n\t      }\n\t\n\t      lib$es6$promise$asap$$len = 0;\n\t    }\n\t\n\t    function lib$es6$promise$asap$$attemptVertx() {\n\t      try {\n\t        var r = require;\n\t        var vertx = __webpack_require__(4);\n\t        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n\t        return lib$es6$promise$asap$$useVertxTimer();\n\t      } catch(e) {\n\t        return lib$es6$promise$asap$$useSetTimeout();\n\t      }\n\t    }\n\t\n\t    var lib$es6$promise$asap$$scheduleFlush;\n\t    // Decide what async method to use to triggering processing of queued callbacks:\n\t    if (lib$es6$promise$asap$$isNode) {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\n\t    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\n\t    } else if (lib$es6$promise$asap$$isWorker) {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\n\t    } else if (lib$es6$promise$asap$$browserWindow === undefined && \"function\" === 'function') {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();\n\t    } else {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\n\t    }\n\t    function lib$es6$promise$then$$then(onFulfillment, onRejection) {\n\t      var parent = this;\n\t      var state = parent._state;\n\t\n\t      if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {\n\t        return this;\n\t      }\n\t\n\t      var child = new this.constructor(lib$es6$promise$$internal$$noop);\n\t      var result = parent._result;\n\t\n\t      if (state) {\n\t        var callback = arguments[state - 1];\n\t        lib$es6$promise$asap$$asap(function(){\n\t          lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);\n\t        });\n\t      } else {\n\t        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n\t      }\n\t\n\t      return child;\n\t    }\n\t    var lib$es6$promise$then$$default = lib$es6$promise$then$$then;\n\t    function lib$es6$promise$promise$resolve$$resolve(object) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t\n\t      if (object && typeof object === 'object' && object.constructor === Constructor) {\n\t        return object;\n\t      }\n\t\n\t      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t      lib$es6$promise$$internal$$resolve(promise, object);\n\t      return promise;\n\t    }\n\t    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\n\t\n\t    function lib$es6$promise$$internal$$noop() {}\n\t\n\t    var lib$es6$promise$$internal$$PENDING   = void 0;\n\t    var lib$es6$promise$$internal$$FULFILLED = 1;\n\t    var lib$es6$promise$$internal$$REJECTED  = 2;\n\t\n\t    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\t\n\t    function lib$es6$promise$$internal$$selfFulfillment() {\n\t      return new TypeError(\"You cannot resolve a promise with itself\");\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$cannotReturnOwn() {\n\t      return new TypeError('A promises callback cannot return that same promise.');\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$getThen(promise) {\n\t      try {\n\t        return promise.then;\n\t      } catch(error) {\n\t        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\n\t        return lib$es6$promise$$internal$$GET_THEN_ERROR;\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n\t      try {\n\t        then.call(value, fulfillmentHandler, rejectionHandler);\n\t      } catch(e) {\n\t        return e;\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\n\t       lib$es6$promise$asap$$asap(function(promise) {\n\t        var sealed = false;\n\t        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {\n\t          if (sealed) { return; }\n\t          sealed = true;\n\t          if (thenable !== value) {\n\t            lib$es6$promise$$internal$$resolve(promise, value);\n\t          } else {\n\t            lib$es6$promise$$internal$$fulfill(promise, value);\n\t          }\n\t        }, function(reason) {\n\t          if (sealed) { return; }\n\t          sealed = true;\n\t\n\t          lib$es6$promise$$internal$$reject(promise, reason);\n\t        }, 'Settle: ' + (promise._label || ' unknown promise'));\n\t\n\t        if (!sealed && error) {\n\t          sealed = true;\n\t          lib$es6$promise$$internal$$reject(promise, error);\n\t        }\n\t      }, promise);\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\n\t      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\n\t        lib$es6$promise$$internal$$fulfill(promise, thenable._result);\n\t      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\n\t        lib$es6$promise$$internal$$reject(promise, thenable._result);\n\t      } else {\n\t        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {\n\t          lib$es6$promise$$internal$$resolve(promise, value);\n\t        }, function(reason) {\n\t          lib$es6$promise$$internal$$reject(promise, reason);\n\t        });\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable, then) {\n\t      if (maybeThenable.constructor === promise.constructor &&\n\t          then === lib$es6$promise$then$$default &&\n\t          constructor.resolve === lib$es6$promise$promise$resolve$$default) {\n\t        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\n\t      } else {\n\t        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\n\t          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\n\t        } else if (then === undefined) {\n\t          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n\t        } else if (lib$es6$promise$utils$$isFunction(then)) {\n\t          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\n\t        } else {\n\t          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n\t        }\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$resolve(promise, value) {\n\t      if (promise === value) {\n\t        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());\n\t      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\n\t        lib$es6$promise$$internal$$handleMaybeThenable(promise, value, lib$es6$promise$$internal$$getThen(value));\n\t      } else {\n\t        lib$es6$promise$$internal$$fulfill(promise, value);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$publishRejection(promise) {\n\t      if (promise._onerror) {\n\t        promise._onerror(promise._result);\n\t      }\n\t\n\t      lib$es6$promise$$internal$$publish(promise);\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$fulfill(promise, value) {\n\t      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\t\n\t      promise._result = value;\n\t      promise._state = lib$es6$promise$$internal$$FULFILLED;\n\t\n\t      if (promise._subscribers.length !== 0) {\n\t        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$reject(promise, reason) {\n\t      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\t      promise._state = lib$es6$promise$$internal$$REJECTED;\n\t      promise._result = reason;\n\t\n\t      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n\t      var subscribers = parent._subscribers;\n\t      var length = subscribers.length;\n\t\n\t      parent._onerror = null;\n\t\n\t      subscribers[length] = child;\n\t      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\n\t      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;\n\t\n\t      if (length === 0 && parent._state) {\n\t        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$publish(promise) {\n\t      var subscribers = promise._subscribers;\n\t      var settled = promise._state;\n\t\n\t      if (subscribers.length === 0) { return; }\n\t\n\t      var child, callback, detail = promise._result;\n\t\n\t      for (var i = 0; i < subscribers.length; i += 3) {\n\t        child = subscribers[i];\n\t        callback = subscribers[i + settled];\n\t\n\t        if (child) {\n\t          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\n\t        } else {\n\t          callback(detail);\n\t        }\n\t      }\n\t\n\t      promise._subscribers.length = 0;\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$ErrorObject() {\n\t      this.error = null;\n\t    }\n\t\n\t    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\t\n\t    function lib$es6$promise$$internal$$tryCatch(callback, detail) {\n\t      try {\n\t        return callback(detail);\n\t      } catch(e) {\n\t        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\n\t        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\n\t      var hasCallback = lib$es6$promise$utils$$isFunction(callback),\n\t          value, error, succeeded, failed;\n\t\n\t      if (hasCallback) {\n\t        value = lib$es6$promise$$internal$$tryCatch(callback, detail);\n\t\n\t        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\n\t          failed = true;\n\t          error = value.error;\n\t          value = null;\n\t        } else {\n\t          succeeded = true;\n\t        }\n\t\n\t        if (promise === value) {\n\t          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\n\t          return;\n\t        }\n\t\n\t      } else {\n\t        value = detail;\n\t        succeeded = true;\n\t      }\n\t\n\t      if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n\t        // noop\n\t      } else if (hasCallback && succeeded) {\n\t        lib$es6$promise$$internal$$resolve(promise, value);\n\t      } else if (failed) {\n\t        lib$es6$promise$$internal$$reject(promise, error);\n\t      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\n\t        lib$es6$promise$$internal$$fulfill(promise, value);\n\t      } else if (settled === lib$es6$promise$$internal$$REJECTED) {\n\t        lib$es6$promise$$internal$$reject(promise, value);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\n\t      try {\n\t        resolver(function resolvePromise(value){\n\t          lib$es6$promise$$internal$$resolve(promise, value);\n\t        }, function rejectPromise(reason) {\n\t          lib$es6$promise$$internal$$reject(promise, reason);\n\t        });\n\t      } catch(e) {\n\t        lib$es6$promise$$internal$$reject(promise, e);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$promise$all$$all(entries) {\n\t      return new lib$es6$promise$enumerator$$default(this, entries).promise;\n\t    }\n\t    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\n\t    function lib$es6$promise$promise$race$$race(entries) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t\n\t      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t\n\t      if (!lib$es6$promise$utils$$isArray(entries)) {\n\t        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n\t        return promise;\n\t      }\n\t\n\t      var length = entries.length;\n\t\n\t      function onFulfillment(value) {\n\t        lib$es6$promise$$internal$$resolve(promise, value);\n\t      }\n\t\n\t      function onRejection(reason) {\n\t        lib$es6$promise$$internal$$reject(promise, reason);\n\t      }\n\t\n\t      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n\t        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n\t      }\n\t\n\t      return promise;\n\t    }\n\t    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\n\t    function lib$es6$promise$promise$reject$$reject(reason) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t      lib$es6$promise$$internal$$reject(promise, reason);\n\t      return promise;\n\t    }\n\t    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\n\t\n\t    var lib$es6$promise$promise$$counter = 0;\n\t\n\t    function lib$es6$promise$promise$$needsResolver() {\n\t      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n\t    }\n\t\n\t    function lib$es6$promise$promise$$needsNew() {\n\t      throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n\t    }\n\t\n\t    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\n\t    /**\n\t      Promise objects represent the eventual result of an asynchronous operation. The\n\t      primary way of interacting with a promise is through its `then` method, which\n\t      registers callbacks to receive either a promise's eventual value or the reason\n\t      why the promise cannot be fulfilled.\n\t\n\t      Terminology\n\t      -----------\n\t\n\t      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n\t      - `thenable` is an object or function that defines a `then` method.\n\t      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n\t      - `exception` is a value that is thrown using the throw statement.\n\t      - `reason` is a value that indicates why a promise was rejected.\n\t      - `settled` the final resting state of a promise, fulfilled or rejected.\n\t\n\t      A promise can be in one of three states: pending, fulfilled, or rejected.\n\t\n\t      Promises that are fulfilled have a fulfillment value and are in the fulfilled\n\t      state.  Promises that are rejected have a rejection reason and are in the\n\t      rejected state.  A fulfillment value is never a thenable.\n\t\n\t      Promises can also be said to *resolve* a value.  If this value is also a\n\t      promise, then the original promise's settled state will match the value's\n\t      settled state.  So a promise that *resolves* a promise that rejects will\n\t      itself reject, and a promise that *resolves* a promise that fulfills will\n\t      itself fulfill.\n\t\n\t\n\t      Basic Usage:\n\t      ------------\n\t\n\t      ```js\n\t      var promise = new Promise(function(resolve, reject) {\n\t        // on success\n\t        resolve(value);\n\t\n\t        // on failure\n\t        reject(reason);\n\t      });\n\t\n\t      promise.then(function(value) {\n\t        // on fulfillment\n\t      }, function(reason) {\n\t        // on rejection\n\t      });\n\t      ```\n\t\n\t      Advanced Usage:\n\t      ---------------\n\t\n\t      Promises shine when abstracting away asynchronous interactions such as\n\t      `XMLHttpRequest`s.\n\t\n\t      ```js\n\t      function getJSON(url) {\n\t        return new Promise(function(resolve, reject){\n\t          var xhr = new XMLHttpRequest();\n\t\n\t          xhr.open('GET', url);\n\t          xhr.onreadystatechange = handler;\n\t          xhr.responseType = 'json';\n\t          xhr.setRequestHeader('Accept', 'application/json');\n\t          xhr.send();\n\t\n\t          function handler() {\n\t            if (this.readyState === this.DONE) {\n\t              if (this.status === 200) {\n\t                resolve(this.response);\n\t              } else {\n\t                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n\t              }\n\t            }\n\t          };\n\t        });\n\t      }\n\t\n\t      getJSON('/posts.json').then(function(json) {\n\t        // on fulfillment\n\t      }, function(reason) {\n\t        // on rejection\n\t      });\n\t      ```\n\t\n\t      Unlike callbacks, promises are great composable primitives.\n\t\n\t      ```js\n\t      Promise.all([\n\t        getJSON('/posts'),\n\t        getJSON('/comments')\n\t      ]).then(function(values){\n\t        values[0] // => postsJSON\n\t        values[1] // => commentsJSON\n\t\n\t        return values;\n\t      });\n\t      ```\n\t\n\t      @class Promise\n\t      @param {function} resolver\n\t      Useful for tooling.\n\t      @constructor\n\t    */\n\t    function lib$es6$promise$promise$$Promise(resolver) {\n\t      this._id = lib$es6$promise$promise$$counter++;\n\t      this._state = undefined;\n\t      this._result = undefined;\n\t      this._subscribers = [];\n\t\n\t      if (lib$es6$promise$$internal$$noop !== resolver) {\n\t        typeof resolver !== 'function' && lib$es6$promise$promise$$needsResolver();\n\t        this instanceof lib$es6$promise$promise$$Promise ? lib$es6$promise$$internal$$initializePromise(this, resolver) : lib$es6$promise$promise$$needsNew();\n\t      }\n\t    }\n\t\n\t    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\n\t    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\n\t    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\n\t    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\n\t    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\n\t    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;\n\t    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;\n\t\n\t    lib$es6$promise$promise$$Promise.prototype = {\n\t      constructor: lib$es6$promise$promise$$Promise,\n\t\n\t    /**\n\t      The primary way of interacting with a promise is through its `then` method,\n\t      which registers callbacks to receive either a promise's eventual value or the\n\t      reason why the promise cannot be fulfilled.\n\t\n\t      ```js\n\t      findUser().then(function(user){\n\t        // user is available\n\t      }, function(reason){\n\t        // user is unavailable, and you are given the reason why\n\t      });\n\t      ```\n\t\n\t      Chaining\n\t      --------\n\t\n\t      The return value of `then` is itself a promise.  This second, 'downstream'\n\t      promise is resolved with the return value of the first promise's fulfillment\n\t      or rejection handler, or rejected if the handler throws an exception.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return user.name;\n\t      }, function (reason) {\n\t        return 'default name';\n\t      }).then(function (userName) {\n\t        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n\t        // will be `'default name'`\n\t      });\n\t\n\t      findUser().then(function (user) {\n\t        throw new Error('Found user, but still unhappy');\n\t      }, function (reason) {\n\t        throw new Error('`findUser` rejected and we're unhappy');\n\t      }).then(function (value) {\n\t        // never reached\n\t      }, function (reason) {\n\t        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n\t        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n\t      });\n\t      ```\n\t      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        throw new PedagogicalException('Upstream error');\n\t      }).then(function (value) {\n\t        // never reached\n\t      }).then(function (value) {\n\t        // never reached\n\t      }, function (reason) {\n\t        // The `PedgagocialException` is propagated all the way down to here\n\t      });\n\t      ```\n\t\n\t      Assimilation\n\t      ------------\n\t\n\t      Sometimes the value you want to propagate to a downstream promise can only be\n\t      retrieved asynchronously. This can be achieved by returning a promise in the\n\t      fulfillment or rejection handler. The downstream promise will then be pending\n\t      until the returned promise is settled. This is called *assimilation*.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return findCommentsByAuthor(user);\n\t      }).then(function (comments) {\n\t        // The user's comments are now available\n\t      });\n\t      ```\n\t\n\t      If the assimliated promise rejects, then the downstream promise will also reject.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return findCommentsByAuthor(user);\n\t      }).then(function (comments) {\n\t        // If `findCommentsByAuthor` fulfills, we'll have the value here\n\t      }, function (reason) {\n\t        // If `findCommentsByAuthor` rejects, we'll have the reason here\n\t      });\n\t      ```\n\t\n\t      Simple Example\n\t      --------------\n\t\n\t      Synchronous Example\n\t\n\t      ```javascript\n\t      var result;\n\t\n\t      try {\n\t        result = findResult();\n\t        // success\n\t      } catch(reason) {\n\t        // failure\n\t      }\n\t      ```\n\t\n\t      Errback Example\n\t\n\t      ```js\n\t      findResult(function(result, err){\n\t        if (err) {\n\t          // failure\n\t        } else {\n\t          // success\n\t        }\n\t      });\n\t      ```\n\t\n\t      Promise Example;\n\t\n\t      ```javascript\n\t      findResult().then(function(result){\n\t        // success\n\t      }, function(reason){\n\t        // failure\n\t      });\n\t      ```\n\t\n\t      Advanced Example\n\t      --------------\n\t\n\t      Synchronous Example\n\t\n\t      ```javascript\n\t      var author, books;\n\t\n\t      try {\n\t        author = findAuthor();\n\t        books  = findBooksByAuthor(author);\n\t        // success\n\t      } catch(reason) {\n\t        // failure\n\t      }\n\t      ```\n\t\n\t      Errback Example\n\t\n\t      ```js\n\t\n\t      function foundBooks(books) {\n\t\n\t      }\n\t\n\t      function failure(reason) {\n\t\n\t      }\n\t\n\t      findAuthor(function(author, err){\n\t        if (err) {\n\t          failure(err);\n\t          // failure\n\t        } else {\n\t          try {\n\t            findBoooksByAuthor(author, function(books, err) {\n\t              if (err) {\n\t                failure(err);\n\t              } else {\n\t                try {\n\t                  foundBooks(books);\n\t                } catch(reason) {\n\t                  failure(reason);\n\t                }\n\t              }\n\t            });\n\t          } catch(error) {\n\t            failure(err);\n\t          }\n\t          // success\n\t        }\n\t      });\n\t      ```\n\t\n\t      Promise Example;\n\t\n\t      ```javascript\n\t      findAuthor().\n\t        then(findBooksByAuthor).\n\t        then(function(books){\n\t          // found books\n\t      }).catch(function(reason){\n\t        // something went wrong\n\t      });\n\t      ```\n\t\n\t      @method then\n\t      @param {Function} onFulfilled\n\t      @param {Function} onRejected\n\t      Useful for tooling.\n\t      @return {Promise}\n\t    */\n\t      then: lib$es6$promise$then$$default,\n\t\n\t    /**\n\t      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n\t      as the catch block of a try/catch statement.\n\t\n\t      ```js\n\t      function findAuthor(){\n\t        throw new Error('couldn't find that author');\n\t      }\n\t\n\t      // synchronous\n\t      try {\n\t        findAuthor();\n\t      } catch(reason) {\n\t        // something went wrong\n\t      }\n\t\n\t      // async with promises\n\t      findAuthor().catch(function(reason){\n\t        // something went wrong\n\t      });\n\t      ```\n\t\n\t      @method catch\n\t      @param {Function} onRejection\n\t      Useful for tooling.\n\t      @return {Promise}\n\t    */\n\t      'catch': function(onRejection) {\n\t        return this.then(null, onRejection);\n\t      }\n\t    };\n\t    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\n\t    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\n\t      this._instanceConstructor = Constructor;\n\t      this.promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t\n\t      if (Array.isArray(input)) {\n\t        this._input     = input;\n\t        this.length     = input.length;\n\t        this._remaining = input.length;\n\t\n\t        this._result = new Array(this.length);\n\t\n\t        if (this.length === 0) {\n\t          lib$es6$promise$$internal$$fulfill(this.promise, this._result);\n\t        } else {\n\t          this.length = this.length || 0;\n\t          this._enumerate();\n\t          if (this._remaining === 0) {\n\t            lib$es6$promise$$internal$$fulfill(this.promise, this._result);\n\t          }\n\t        }\n\t      } else {\n\t        lib$es6$promise$$internal$$reject(this.promise, this._validationError());\n\t      }\n\t    }\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {\n\t      return new Error('Array Methods must be provided an Array');\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {\n\t      var length  = this.length;\n\t      var input   = this._input;\n\t\n\t      for (var i = 0; this._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n\t        this._eachEntry(input[i], i);\n\t      }\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n\t      var c = this._instanceConstructor;\n\t      var resolve = c.resolve;\n\t\n\t      if (resolve === lib$es6$promise$promise$resolve$$default) {\n\t        var then = lib$es6$promise$$internal$$getThen(entry);\n\t\n\t        if (then === lib$es6$promise$then$$default &&\n\t            entry._state !== lib$es6$promise$$internal$$PENDING) {\n\t          this._settledAt(entry._state, i, entry._result);\n\t        } else if (typeof then !== 'function') {\n\t          this._remaining--;\n\t          this._result[i] = entry;\n\t        } else if (c === lib$es6$promise$promise$$default) {\n\t          var promise = new c(lib$es6$promise$$internal$$noop);\n\t          lib$es6$promise$$internal$$handleMaybeThenable(promise, entry, then);\n\t          this._willSettleAt(promise, i);\n\t        } else {\n\t          this._willSettleAt(new c(function(resolve) { resolve(entry); }), i);\n\t        }\n\t      } else {\n\t        this._willSettleAt(resolve(entry), i);\n\t      }\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n\t      var promise = this.promise;\n\t\n\t      if (promise._state === lib$es6$promise$$internal$$PENDING) {\n\t        this._remaining--;\n\t\n\t        if (state === lib$es6$promise$$internal$$REJECTED) {\n\t          lib$es6$promise$$internal$$reject(promise, value);\n\t        } else {\n\t          this._result[i] = value;\n\t        }\n\t      }\n\t\n\t      if (this._remaining === 0) {\n\t        lib$es6$promise$$internal$$fulfill(promise, this._result);\n\t      }\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n\t      var enumerator = this;\n\t\n\t      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {\n\t        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\n\t      }, function(reason) {\n\t        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\n\t      });\n\t    };\n\t    function lib$es6$promise$polyfill$$polyfill() {\n\t      var local;\n\t\n\t      if (typeof global !== 'undefined') {\n\t          local = global;\n\t      } else if (typeof self !== 'undefined') {\n\t          local = self;\n\t      } else {\n\t          try {\n\t              local = Function('return this')();\n\t          } catch (e) {\n\t              throw new Error('polyfill failed because global object is unavailable in this environment');\n\t          }\n\t      }\n\t\n\t      var P = local.Promise;\n\t\n\t      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\n\t        return;\n\t      }\n\t\n\t      local.Promise = lib$es6$promise$promise$$default;\n\t    }\n\t    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\n\t\n\t    var lib$es6$promise$umd$$ES6Promise = {\n\t      'Promise': lib$es6$promise$promise$$default,\n\t      'polyfill': lib$es6$promise$polyfill$$default\n\t    };\n\t\n\t    /* global define:true module:true window: true */\n\t    if (\"function\" === 'function' && __webpack_require__(5)['amd']) {\n\t      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof module !== 'undefined' && module['exports']) {\n\t      module['exports'] = lib$es6$promise$umd$$ES6Promise;\n\t    } else if (typeof this !== 'undefined') {\n\t      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\n\t    }\n\t\n\t    lib$es6$promise$polyfill$$default();\n\t}).call(this);\n\t\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), (function() { return this; }()), __webpack_require__(3)(module)))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t/* (ignored) */\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t(function(self) {\n\t  'use strict';\n\t\n\t  if (self.fetch) {\n\t    return\n\t  }\n\t\n\t  function normalizeName(name) {\n\t    if (typeof name !== 'string') {\n\t      name = String(name)\n\t    }\n\t    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n\t      throw new TypeError('Invalid character in header field name')\n\t    }\n\t    return name.toLowerCase()\n\t  }\n\t\n\t  function normalizeValue(value) {\n\t    if (typeof value !== 'string') {\n\t      value = String(value)\n\t    }\n\t    return value\n\t  }\n\t\n\t  function Headers(headers) {\n\t    this.map = {}\n\t\n\t    if (headers instanceof Headers) {\n\t      headers.forEach(function(value, name) {\n\t        this.append(name, value)\n\t      }, this)\n\t\n\t    } else if (headers) {\n\t      Object.getOwnPropertyNames(headers).forEach(function(name) {\n\t        this.append(name, headers[name])\n\t      }, this)\n\t    }\n\t  }\n\t\n\t  Headers.prototype.append = function(name, value) {\n\t    name = normalizeName(name)\n\t    value = normalizeValue(value)\n\t    var list = this.map[name]\n\t    if (!list) {\n\t      list = []\n\t      this.map[name] = list\n\t    }\n\t    list.push(value)\n\t  }\n\t\n\t  Headers.prototype['delete'] = function(name) {\n\t    delete this.map[normalizeName(name)]\n\t  }\n\t\n\t  Headers.prototype.get = function(name) {\n\t    var values = this.map[normalizeName(name)]\n\t    return values ? values[0] : null\n\t  }\n\t\n\t  Headers.prototype.getAll = function(name) {\n\t    return this.map[normalizeName(name)] || []\n\t  }\n\t\n\t  Headers.prototype.has = function(name) {\n\t    return this.map.hasOwnProperty(normalizeName(name))\n\t  }\n\t\n\t  Headers.prototype.set = function(name, value) {\n\t    this.map[normalizeName(name)] = [normalizeValue(value)]\n\t  }\n\t\n\t  Headers.prototype.forEach = function(callback, thisArg) {\n\t    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n\t      this.map[name].forEach(function(value) {\n\t        callback.call(thisArg, value, name, this)\n\t      }, this)\n\t    }, this)\n\t  }\n\t\n\t  function consumed(body) {\n\t    if (body.bodyUsed) {\n\t      return Promise.reject(new TypeError('Already read'))\n\t    }\n\t    body.bodyUsed = true\n\t  }\n\t\n\t  function fileReaderReady(reader) {\n\t    return new Promise(function(resolve, reject) {\n\t      reader.onload = function() {\n\t        resolve(reader.result)\n\t      }\n\t      reader.onerror = function() {\n\t        reject(reader.error)\n\t      }\n\t    })\n\t  }\n\t\n\t  function readBlobAsArrayBuffer(blob) {\n\t    var reader = new FileReader()\n\t    reader.readAsArrayBuffer(blob)\n\t    return fileReaderReady(reader)\n\t  }\n\t\n\t  function readBlobAsText(blob) {\n\t    var reader = new FileReader()\n\t    reader.readAsText(blob)\n\t    return fileReaderReady(reader)\n\t  }\n\t\n\t  var support = {\n\t    blob: 'FileReader' in self && 'Blob' in self && (function() {\n\t      try {\n\t        new Blob();\n\t        return true\n\t      } catch(e) {\n\t        return false\n\t      }\n\t    })(),\n\t    formData: 'FormData' in self,\n\t    arrayBuffer: 'ArrayBuffer' in self\n\t  }\n\t\n\t  function Body() {\n\t    this.bodyUsed = false\n\t\n\t\n\t    this._initBody = function(body) {\n\t      this._bodyInit = body\n\t      if (typeof body === 'string') {\n\t        this._bodyText = body\n\t      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n\t        this._bodyBlob = body\n\t      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n\t        this._bodyFormData = body\n\t      } else if (!body) {\n\t        this._bodyText = ''\n\t      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {\n\t        // Only support ArrayBuffers for POST method.\n\t        // Receiving ArrayBuffers happens via Blobs, instead.\n\t      } else {\n\t        throw new Error('unsupported BodyInit type')\n\t      }\n\t\n\t      if (!this.headers.get('content-type')) {\n\t        if (typeof body === 'string') {\n\t          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n\t        } else if (this._bodyBlob && this._bodyBlob.type) {\n\t          this.headers.set('content-type', this._bodyBlob.type)\n\t        }\n\t      }\n\t    }\n\t\n\t    if (support.blob) {\n\t      this.blob = function() {\n\t        var rejected = consumed(this)\n\t        if (rejected) {\n\t          return rejected\n\t        }\n\t\n\t        if (this._bodyBlob) {\n\t          return Promise.resolve(this._bodyBlob)\n\t        } else if (this._bodyFormData) {\n\t          throw new Error('could not read FormData body as blob')\n\t        } else {\n\t          return Promise.resolve(new Blob([this._bodyText]))\n\t        }\n\t      }\n\t\n\t      this.arrayBuffer = function() {\n\t        return this.blob().then(readBlobAsArrayBuffer)\n\t      }\n\t\n\t      this.text = function() {\n\t        var rejected = consumed(this)\n\t        if (rejected) {\n\t          return rejected\n\t        }\n\t\n\t        if (this._bodyBlob) {\n\t          return readBlobAsText(this._bodyBlob)\n\t        } else if (this._bodyFormData) {\n\t          throw new Error('could not read FormData body as text')\n\t        } else {\n\t          return Promise.resolve(this._bodyText)\n\t        }\n\t      }\n\t    } else {\n\t      this.text = function() {\n\t        var rejected = consumed(this)\n\t        return rejected ? rejected : Promise.resolve(this._bodyText)\n\t      }\n\t    }\n\t\n\t    if (support.formData) {\n\t      this.formData = function() {\n\t        return this.text().then(decode)\n\t      }\n\t    }\n\t\n\t    this.json = function() {\n\t      return this.text().then(JSON.parse)\n\t    }\n\t\n\t    return this\n\t  }\n\t\n\t  // HTTP methods whose capitalization should be normalized\n\t  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\t\n\t  function normalizeMethod(method) {\n\t    var upcased = method.toUpperCase()\n\t    return (methods.indexOf(upcased) > -1) ? upcased : method\n\t  }\n\t\n\t  function Request(input, options) {\n\t    options = options || {}\n\t    var body = options.body\n\t    if (Request.prototype.isPrototypeOf(input)) {\n\t      if (input.bodyUsed) {\n\t        throw new TypeError('Already read')\n\t      }\n\t      this.url = input.url\n\t      this.credentials = input.credentials\n\t      if (!options.headers) {\n\t        this.headers = new Headers(input.headers)\n\t      }\n\t      this.method = input.method\n\t      this.mode = input.mode\n\t      if (!body) {\n\t        body = input._bodyInit\n\t        input.bodyUsed = true\n\t      }\n\t    } else {\n\t      this.url = input\n\t    }\n\t\n\t    this.credentials = options.credentials || this.credentials || 'omit'\n\t    if (options.headers || !this.headers) {\n\t      this.headers = new Headers(options.headers)\n\t    }\n\t    this.method = normalizeMethod(options.method || this.method || 'GET')\n\t    this.mode = options.mode || this.mode || null\n\t    this.referrer = null\n\t\n\t    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n\t      throw new TypeError('Body not allowed for GET or HEAD requests')\n\t    }\n\t    this._initBody(body)\n\t  }\n\t\n\t  Request.prototype.clone = function() {\n\t    return new Request(this)\n\t  }\n\t\n\t  function decode(body) {\n\t    var form = new FormData()\n\t    body.trim().split('&').forEach(function(bytes) {\n\t      if (bytes) {\n\t        var split = bytes.split('=')\n\t        var name = split.shift().replace(/\\+/g, ' ')\n\t        var value = split.join('=').replace(/\\+/g, ' ')\n\t        form.append(decodeURIComponent(name), decodeURIComponent(value))\n\t      }\n\t    })\n\t    return form\n\t  }\n\t\n\t  function headers(xhr) {\n\t    var head = new Headers()\n\t    var pairs = xhr.getAllResponseHeaders().trim().split('\\n')\n\t    pairs.forEach(function(header) {\n\t      var split = header.trim().split(':')\n\t      var key = split.shift().trim()\n\t      var value = split.join(':').trim()\n\t      head.append(key, value)\n\t    })\n\t    return head\n\t  }\n\t\n\t  Body.call(Request.prototype)\n\t\n\t  function Response(bodyInit, options) {\n\t    if (!options) {\n\t      options = {}\n\t    }\n\t\n\t    this.type = 'default'\n\t    this.status = options.status\n\t    this.ok = this.status >= 200 && this.status < 300\n\t    this.statusText = options.statusText\n\t    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n\t    this.url = options.url || ''\n\t    this._initBody(bodyInit)\n\t  }\n\t\n\t  Body.call(Response.prototype)\n\t\n\t  Response.prototype.clone = function() {\n\t    return new Response(this._bodyInit, {\n\t      status: this.status,\n\t      statusText: this.statusText,\n\t      headers: new Headers(this.headers),\n\t      url: this.url\n\t    })\n\t  }\n\t\n\t  Response.error = function() {\n\t    var response = new Response(null, {status: 0, statusText: ''})\n\t    response.type = 'error'\n\t    return response\n\t  }\n\t\n\t  var redirectStatuses = [301, 302, 303, 307, 308]\n\t\n\t  Response.redirect = function(url, status) {\n\t    if (redirectStatuses.indexOf(status) === -1) {\n\t      throw new RangeError('Invalid status code')\n\t    }\n\t\n\t    return new Response(null, {status: status, headers: {location: url}})\n\t  }\n\t\n\t  self.Headers = Headers;\n\t  self.Request = Request;\n\t  self.Response = Response;\n\t\n\t  self.fetch = function(input, init) {\n\t    return new Promise(function(resolve, reject) {\n\t      var request\n\t      if (Request.prototype.isPrototypeOf(input) && !init) {\n\t        request = input\n\t      } else {\n\t        request = new Request(input, init)\n\t      }\n\t\n\t      var xhr = new XMLHttpRequest()\n\t\n\t      function responseURL() {\n\t        if ('responseURL' in xhr) {\n\t          return xhr.responseURL\n\t        }\n\t\n\t        // Avoid security warnings on getResponseHeader when not allowed by CORS\n\t        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n\t          return xhr.getResponseHeader('X-Request-URL')\n\t        }\n\t\n\t        return;\n\t      }\n\t\n\t      xhr.onload = function() {\n\t        var status = (xhr.status === 1223) ? 204 : xhr.status\n\t        if (status < 100 || status > 599) {\n\t          reject(new TypeError('Network request failed'))\n\t          return\n\t        }\n\t        var options = {\n\t          status: status,\n\t          statusText: xhr.statusText,\n\t          headers: headers(xhr),\n\t          url: responseURL()\n\t        }\n\t        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n\t        resolve(new Response(body, options))\n\t      }\n\t\n\t      xhr.onerror = function() {\n\t        reject(new TypeError('Network request failed'))\n\t      }\n\t\n\t      xhr.open(request.method, request.url, true)\n\t\n\t      if (request.credentials === 'include') {\n\t        xhr.withCredentials = true\n\t      }\n\t\n\t      if ('responseType' in xhr && support.blob) {\n\t        xhr.responseType = 'blob'\n\t      }\n\t\n\t      request.headers.forEach(function(value, name) {\n\t        xhr.setRequestHeader(name, value)\n\t      })\n\t\n\t      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n\t    })\n\t  }\n\t  self.fetch.polyfill = true\n\t})(typeof self !== 'undefined' ? self : this);\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** fetch-it.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 18e20dda084afeeea939\n **/","import 'es6-promise';\nimport 'whatwg-fetch';\n\n\nconst DEFAULT_CONFIG = {};\n\n\nclass FetchIt {\n  constructor(config) {\n    this.config = config || DEFAULT_CONFIG;\n    this.middlewares = [];\n  }\n\n  _createRequest(url, options, method, data) {\n    if (!options && !method && !data) {\n      return new window.Request(url);\n    }\n\n    let defaultMethod = !data && (!!options && !options.body) ? 'GET' : 'POST';\n\n    options = Object.assign({}, this.config, options || {});\n    options.method = method || options.method || defaultMethod;\n    if (!!data) {\n      if (data instanceof window.Blob || data instanceof window.FormData ||\n          typeof data === 'string') {\n        options.body = data;\n      } else {\n        options.body = window.JSON.stringify(data);\n      }\n    }\n\n    return new window.Request(url, options);\n  }\n\n  _request(urlOrRequest, ...options) {\n    let request;\n    if (urlOrRequest instanceof window.Request) {\n      request = urlOrRequest;\n    } else {\n      request = this._createRequest(urlOrRequest, ...options);\n    }\n\n    let promise = window.Promise.resolve(request);\n    let chain = [window.fetch, undefined];\n\n    for (let middleware of this.middlewares.reverse()) {\n      chain.unshift(middleware.request, middleware.requestError);\n      chain.push(middleware.response, middleware.responseError);\n    }\n\n    while (!!chain.length) {\n      promise = promise.then(chain.shift(), chain.shift());\n    }\n\n    return promise;\n  }\n\n  addMiddlewares(middlewares) {\n    this.middlewares.push(...middlewares);\n  }\n\n  clearMiddlewares() {\n    this.middlewares = [];\n  }\n\n  fetch(url, options) {\n    return this._request(url, options);\n  }\n\n  get(url, options) {\n    return this._request(url, options, 'GET');\n  }\n\n  post(url, data, options) {\n    return this._request(url, options, 'POST', data);\n  }\n\n  patch(url, data, options) {\n    return this._request(url, options, 'PATCH', data);\n  }\n\n  put(url, data, options) {\n    return this._request(url, options, 'PUT', data);\n  }\n\n  delete(url, options) {\n    return this._request(url, options, 'DELETE');\n  }\n\n  head(url, options) {\n    return this._request(url, options, 'HEAD');\n  }\n}\n\n\nlet jsonMiddleware = {\n  response(res) {\n    return res.json().catch((e) => {\n      return e;\n    });\n  }\n};\n\n\nclass FetchItFactory {\n  constructor() {\n    this.instance = new FetchIt();\n    this.middleware = {\n      jsonMiddleware\n    };\n  }\n\n  create(config) {\n    return new FetchIt(config);\n  }\n\n  addMiddlewares(middlewares) {\n    this.instance.addMiddlewares(middlewares);\n  }\n\n  clearMiddlewares() {\n    this.instance.clearMiddlewares();\n  }\n\n  fetch(...args) {\n    return this.instance.fetch(...args);\n  }\n\n  get(...args) {\n    return this.instance.get(...args);\n  }\n\n  post(...args) {\n    return this.instance.post(...args);\n  }\n\n  patch(...args) {\n    return this.instance.patch(...args);\n  }\n\n  put(...args) {\n    return this.instance.put(...args);\n  }\n\n  delete(...args) {\n    return this.instance.delete(...args);\n  }\n\n  head(...args) {\n    return this.instance.head(...args);\n  }\n}\n\n\nexport default new FetchItFactory();\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/fetch-it.js\n **/","/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n * @version   3.1.2\n */\n\n(function() {\n    \"use strict\";\n    function lib$es6$promise$utils$$objectOrFunction(x) {\n      return typeof x === 'function' || (typeof x === 'object' && x !== null);\n    }\n\n    function lib$es6$promise$utils$$isFunction(x) {\n      return typeof x === 'function';\n    }\n\n    function lib$es6$promise$utils$$isMaybeThenable(x) {\n      return typeof x === 'object' && x !== null;\n    }\n\n    var lib$es6$promise$utils$$_isArray;\n    if (!Array.isArray) {\n      lib$es6$promise$utils$$_isArray = function (x) {\n        return Object.prototype.toString.call(x) === '[object Array]';\n      };\n    } else {\n      lib$es6$promise$utils$$_isArray = Array.isArray;\n    }\n\n    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\n    var lib$es6$promise$asap$$len = 0;\n    var lib$es6$promise$asap$$vertxNext;\n    var lib$es6$promise$asap$$customSchedulerFn;\n\n    var lib$es6$promise$asap$$asap = function asap(callback, arg) {\n      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\n      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\n      lib$es6$promise$asap$$len += 2;\n      if (lib$es6$promise$asap$$len === 2) {\n        // If len is 2, that means that we need to schedule an async flush.\n        // If additional callbacks are queued before the queue is flushed, they\n        // will be processed by this flush that we are scheduling.\n        if (lib$es6$promise$asap$$customSchedulerFn) {\n          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\n        } else {\n          lib$es6$promise$asap$$scheduleFlush();\n        }\n      }\n    }\n\n    function lib$es6$promise$asap$$setScheduler(scheduleFn) {\n      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\n    }\n\n    function lib$es6$promise$asap$$setAsap(asapFn) {\n      lib$es6$promise$asap$$asap = asapFn;\n    }\n\n    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;\n    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\n    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\n    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n    // test for web worker but not in IE10\n    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n      typeof importScripts !== 'undefined' &&\n      typeof MessageChannel !== 'undefined';\n\n    // node\n    function lib$es6$promise$asap$$useNextTick() {\n      // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n      // see https://github.com/cujojs/when/issues/410 for details\n      return function() {\n        process.nextTick(lib$es6$promise$asap$$flush);\n      };\n    }\n\n    // vertx\n    function lib$es6$promise$asap$$useVertxTimer() {\n      return function() {\n        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\n      };\n    }\n\n    function lib$es6$promise$asap$$useMutationObserver() {\n      var iterations = 0;\n      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\n      var node = document.createTextNode('');\n      observer.observe(node, { characterData: true });\n\n      return function() {\n        node.data = (iterations = ++iterations % 2);\n      };\n    }\n\n    // web worker\n    function lib$es6$promise$asap$$useMessageChannel() {\n      var channel = new MessageChannel();\n      channel.port1.onmessage = lib$es6$promise$asap$$flush;\n      return function () {\n        channel.port2.postMessage(0);\n      };\n    }\n\n    function lib$es6$promise$asap$$useSetTimeout() {\n      return function() {\n        setTimeout(lib$es6$promise$asap$$flush, 1);\n      };\n    }\n\n    var lib$es6$promise$asap$$queue = new Array(1000);\n    function lib$es6$promise$asap$$flush() {\n      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {\n        var callback = lib$es6$promise$asap$$queue[i];\n        var arg = lib$es6$promise$asap$$queue[i+1];\n\n        callback(arg);\n\n        lib$es6$promise$asap$$queue[i] = undefined;\n        lib$es6$promise$asap$$queue[i+1] = undefined;\n      }\n\n      lib$es6$promise$asap$$len = 0;\n    }\n\n    function lib$es6$promise$asap$$attemptVertx() {\n      try {\n        var r = require;\n        var vertx = r('vertx');\n        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n        return lib$es6$promise$asap$$useVertxTimer();\n      } catch(e) {\n        return lib$es6$promise$asap$$useSetTimeout();\n      }\n    }\n\n    var lib$es6$promise$asap$$scheduleFlush;\n    // Decide what async method to use to triggering processing of queued callbacks:\n    if (lib$es6$promise$asap$$isNode) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\n    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\n    } else if (lib$es6$promise$asap$$isWorker) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\n    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();\n    } else {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\n    }\n    function lib$es6$promise$then$$then(onFulfillment, onRejection) {\n      var parent = this;\n      var state = parent._state;\n\n      if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {\n        return this;\n      }\n\n      var child = new this.constructor(lib$es6$promise$$internal$$noop);\n      var result = parent._result;\n\n      if (state) {\n        var callback = arguments[state - 1];\n        lib$es6$promise$asap$$asap(function(){\n          lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);\n        });\n      } else {\n        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n      }\n\n      return child;\n    }\n    var lib$es6$promise$then$$default = lib$es6$promise$then$$then;\n    function lib$es6$promise$promise$resolve$$resolve(object) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      if (object && typeof object === 'object' && object.constructor === Constructor) {\n        return object;\n      }\n\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n      lib$es6$promise$$internal$$resolve(promise, object);\n      return promise;\n    }\n    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\n\n    function lib$es6$promise$$internal$$noop() {}\n\n    var lib$es6$promise$$internal$$PENDING   = void 0;\n    var lib$es6$promise$$internal$$FULFILLED = 1;\n    var lib$es6$promise$$internal$$REJECTED  = 2;\n\n    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n    function lib$es6$promise$$internal$$selfFulfillment() {\n      return new TypeError(\"You cannot resolve a promise with itself\");\n    }\n\n    function lib$es6$promise$$internal$$cannotReturnOwn() {\n      return new TypeError('A promises callback cannot return that same promise.');\n    }\n\n    function lib$es6$promise$$internal$$getThen(promise) {\n      try {\n        return promise.then;\n      } catch(error) {\n        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\n        return lib$es6$promise$$internal$$GET_THEN_ERROR;\n      }\n    }\n\n    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n      try {\n        then.call(value, fulfillmentHandler, rejectionHandler);\n      } catch(e) {\n        return e;\n      }\n    }\n\n    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\n       lib$es6$promise$asap$$asap(function(promise) {\n        var sealed = false;\n        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {\n          if (sealed) { return; }\n          sealed = true;\n          if (thenable !== value) {\n            lib$es6$promise$$internal$$resolve(promise, value);\n          } else {\n            lib$es6$promise$$internal$$fulfill(promise, value);\n          }\n        }, function(reason) {\n          if (sealed) { return; }\n          sealed = true;\n\n          lib$es6$promise$$internal$$reject(promise, reason);\n        }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n        if (!sealed && error) {\n          sealed = true;\n          lib$es6$promise$$internal$$reject(promise, error);\n        }\n      }, promise);\n    }\n\n    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\n      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\n        lib$es6$promise$$internal$$fulfill(promise, thenable._result);\n      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, thenable._result);\n      } else {\n        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {\n          lib$es6$promise$$internal$$resolve(promise, value);\n        }, function(reason) {\n          lib$es6$promise$$internal$$reject(promise, reason);\n        });\n      }\n    }\n\n    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable, then) {\n      if (maybeThenable.constructor === promise.constructor &&\n          then === lib$es6$promise$then$$default &&\n          constructor.resolve === lib$es6$promise$promise$resolve$$default) {\n        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\n      } else {\n        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\n          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\n        } else if (then === undefined) {\n          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n        } else if (lib$es6$promise$utils$$isFunction(then)) {\n          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\n        } else {\n          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n        }\n      }\n    }\n\n    function lib$es6$promise$$internal$$resolve(promise, value) {\n      if (promise === value) {\n        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());\n      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\n        lib$es6$promise$$internal$$handleMaybeThenable(promise, value, lib$es6$promise$$internal$$getThen(value));\n      } else {\n        lib$es6$promise$$internal$$fulfill(promise, value);\n      }\n    }\n\n    function lib$es6$promise$$internal$$publishRejection(promise) {\n      if (promise._onerror) {\n        promise._onerror(promise._result);\n      }\n\n      lib$es6$promise$$internal$$publish(promise);\n    }\n\n    function lib$es6$promise$$internal$$fulfill(promise, value) {\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\n      promise._result = value;\n      promise._state = lib$es6$promise$$internal$$FULFILLED;\n\n      if (promise._subscribers.length !== 0) {\n        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);\n      }\n    }\n\n    function lib$es6$promise$$internal$$reject(promise, reason) {\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n      promise._state = lib$es6$promise$$internal$$REJECTED;\n      promise._result = reason;\n\n      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);\n    }\n\n    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n      var subscribers = parent._subscribers;\n      var length = subscribers.length;\n\n      parent._onerror = null;\n\n      subscribers[length] = child;\n      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\n      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;\n\n      if (length === 0 && parent._state) {\n        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);\n      }\n    }\n\n    function lib$es6$promise$$internal$$publish(promise) {\n      var subscribers = promise._subscribers;\n      var settled = promise._state;\n\n      if (subscribers.length === 0) { return; }\n\n      var child, callback, detail = promise._result;\n\n      for (var i = 0; i < subscribers.length; i += 3) {\n        child = subscribers[i];\n        callback = subscribers[i + settled];\n\n        if (child) {\n          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\n        } else {\n          callback(detail);\n        }\n      }\n\n      promise._subscribers.length = 0;\n    }\n\n    function lib$es6$promise$$internal$$ErrorObject() {\n      this.error = null;\n    }\n\n    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n    function lib$es6$promise$$internal$$tryCatch(callback, detail) {\n      try {\n        return callback(detail);\n      } catch(e) {\n        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\n        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\n      }\n    }\n\n    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\n      var hasCallback = lib$es6$promise$utils$$isFunction(callback),\n          value, error, succeeded, failed;\n\n      if (hasCallback) {\n        value = lib$es6$promise$$internal$$tryCatch(callback, detail);\n\n        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\n          failed = true;\n          error = value.error;\n          value = null;\n        } else {\n          succeeded = true;\n        }\n\n        if (promise === value) {\n          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\n          return;\n        }\n\n      } else {\n        value = detail;\n        succeeded = true;\n      }\n\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n        // noop\n      } else if (hasCallback && succeeded) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      } else if (failed) {\n        lib$es6$promise$$internal$$reject(promise, error);\n      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\n        lib$es6$promise$$internal$$fulfill(promise, value);\n      } else if (settled === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, value);\n      }\n    }\n\n    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\n      try {\n        resolver(function resolvePromise(value){\n          lib$es6$promise$$internal$$resolve(promise, value);\n        }, function rejectPromise(reason) {\n          lib$es6$promise$$internal$$reject(promise, reason);\n        });\n      } catch(e) {\n        lib$es6$promise$$internal$$reject(promise, e);\n      }\n    }\n\n    function lib$es6$promise$promise$all$$all(entries) {\n      return new lib$es6$promise$enumerator$$default(this, entries).promise;\n    }\n    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\n    function lib$es6$promise$promise$race$$race(entries) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n      if (!lib$es6$promise$utils$$isArray(entries)) {\n        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n        return promise;\n      }\n\n      var length = entries.length;\n\n      function onFulfillment(value) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      }\n\n      function onRejection(reason) {\n        lib$es6$promise$$internal$$reject(promise, reason);\n      }\n\n      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n      }\n\n      return promise;\n    }\n    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\n    function lib$es6$promise$promise$reject$$reject(reason) {\n      /*jshint validthis:true */\n      var Constructor = this;\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n      lib$es6$promise$$internal$$reject(promise, reason);\n      return promise;\n    }\n    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\n\n    var lib$es6$promise$promise$$counter = 0;\n\n    function lib$es6$promise$promise$$needsResolver() {\n      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n    }\n\n    function lib$es6$promise$promise$$needsNew() {\n      throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n    }\n\n    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\n    /**\n      Promise objects represent the eventual result of an asynchronous operation. The\n      primary way of interacting with a promise is through its `then` method, which\n      registers callbacks to receive either a promise's eventual value or the reason\n      why the promise cannot be fulfilled.\n\n      Terminology\n      -----------\n\n      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n      - `thenable` is an object or function that defines a `then` method.\n      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n      - `exception` is a value that is thrown using the throw statement.\n      - `reason` is a value that indicates why a promise was rejected.\n      - `settled` the final resting state of a promise, fulfilled or rejected.\n\n      A promise can be in one of three states: pending, fulfilled, or rejected.\n\n      Promises that are fulfilled have a fulfillment value and are in the fulfilled\n      state.  Promises that are rejected have a rejection reason and are in the\n      rejected state.  A fulfillment value is never a thenable.\n\n      Promises can also be said to *resolve* a value.  If this value is also a\n      promise, then the original promise's settled state will match the value's\n      settled state.  So a promise that *resolves* a promise that rejects will\n      itself reject, and a promise that *resolves* a promise that fulfills will\n      itself fulfill.\n\n\n      Basic Usage:\n      ------------\n\n      ```js\n      var promise = new Promise(function(resolve, reject) {\n        // on success\n        resolve(value);\n\n        // on failure\n        reject(reason);\n      });\n\n      promise.then(function(value) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Advanced Usage:\n      ---------------\n\n      Promises shine when abstracting away asynchronous interactions such as\n      `XMLHttpRequest`s.\n\n      ```js\n      function getJSON(url) {\n        return new Promise(function(resolve, reject){\n          var xhr = new XMLHttpRequest();\n\n          xhr.open('GET', url);\n          xhr.onreadystatechange = handler;\n          xhr.responseType = 'json';\n          xhr.setRequestHeader('Accept', 'application/json');\n          xhr.send();\n\n          function handler() {\n            if (this.readyState === this.DONE) {\n              if (this.status === 200) {\n                resolve(this.response);\n              } else {\n                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n              }\n            }\n          };\n        });\n      }\n\n      getJSON('/posts.json').then(function(json) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Unlike callbacks, promises are great composable primitives.\n\n      ```js\n      Promise.all([\n        getJSON('/posts'),\n        getJSON('/comments')\n      ]).then(function(values){\n        values[0] // => postsJSON\n        values[1] // => commentsJSON\n\n        return values;\n      });\n      ```\n\n      @class Promise\n      @param {function} resolver\n      Useful for tooling.\n      @constructor\n    */\n    function lib$es6$promise$promise$$Promise(resolver) {\n      this._id = lib$es6$promise$promise$$counter++;\n      this._state = undefined;\n      this._result = undefined;\n      this._subscribers = [];\n\n      if (lib$es6$promise$$internal$$noop !== resolver) {\n        typeof resolver !== 'function' && lib$es6$promise$promise$$needsResolver();\n        this instanceof lib$es6$promise$promise$$Promise ? lib$es6$promise$$internal$$initializePromise(this, resolver) : lib$es6$promise$promise$$needsNew();\n      }\n    }\n\n    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\n    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\n    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\n    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\n    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\n    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;\n    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;\n\n    lib$es6$promise$promise$$Promise.prototype = {\n      constructor: lib$es6$promise$promise$$Promise,\n\n    /**\n      The primary way of interacting with a promise is through its `then` method,\n      which registers callbacks to receive either a promise's eventual value or the\n      reason why the promise cannot be fulfilled.\n\n      ```js\n      findUser().then(function(user){\n        // user is available\n      }, function(reason){\n        // user is unavailable, and you are given the reason why\n      });\n      ```\n\n      Chaining\n      --------\n\n      The return value of `then` is itself a promise.  This second, 'downstream'\n      promise is resolved with the return value of the first promise's fulfillment\n      or rejection handler, or rejected if the handler throws an exception.\n\n      ```js\n      findUser().then(function (user) {\n        return user.name;\n      }, function (reason) {\n        return 'default name';\n      }).then(function (userName) {\n        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n        // will be `'default name'`\n      });\n\n      findUser().then(function (user) {\n        throw new Error('Found user, but still unhappy');\n      }, function (reason) {\n        throw new Error('`findUser` rejected and we're unhappy');\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n      });\n      ```\n      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\n      ```js\n      findUser().then(function (user) {\n        throw new PedagogicalException('Upstream error');\n      }).then(function (value) {\n        // never reached\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // The `PedgagocialException` is propagated all the way down to here\n      });\n      ```\n\n      Assimilation\n      ------------\n\n      Sometimes the value you want to propagate to a downstream promise can only be\n      retrieved asynchronously. This can be achieved by returning a promise in the\n      fulfillment or rejection handler. The downstream promise will then be pending\n      until the returned promise is settled. This is called *assimilation*.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // The user's comments are now available\n      });\n      ```\n\n      If the assimliated promise rejects, then the downstream promise will also reject.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // If `findCommentsByAuthor` fulfills, we'll have the value here\n      }, function (reason) {\n        // If `findCommentsByAuthor` rejects, we'll have the reason here\n      });\n      ```\n\n      Simple Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var result;\n\n      try {\n        result = findResult();\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n      findResult(function(result, err){\n        if (err) {\n          // failure\n        } else {\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findResult().then(function(result){\n        // success\n      }, function(reason){\n        // failure\n      });\n      ```\n\n      Advanced Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var author, books;\n\n      try {\n        author = findAuthor();\n        books  = findBooksByAuthor(author);\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n\n      function foundBooks(books) {\n\n      }\n\n      function failure(reason) {\n\n      }\n\n      findAuthor(function(author, err){\n        if (err) {\n          failure(err);\n          // failure\n        } else {\n          try {\n            findBoooksByAuthor(author, function(books, err) {\n              if (err) {\n                failure(err);\n              } else {\n                try {\n                  foundBooks(books);\n                } catch(reason) {\n                  failure(reason);\n                }\n              }\n            });\n          } catch(error) {\n            failure(err);\n          }\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findAuthor().\n        then(findBooksByAuthor).\n        then(function(books){\n          // found books\n      }).catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method then\n      @param {Function} onFulfilled\n      @param {Function} onRejected\n      Useful for tooling.\n      @return {Promise}\n    */\n      then: lib$es6$promise$then$$default,\n\n    /**\n      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n      as the catch block of a try/catch statement.\n\n      ```js\n      function findAuthor(){\n        throw new Error('couldn't find that author');\n      }\n\n      // synchronous\n      try {\n        findAuthor();\n      } catch(reason) {\n        // something went wrong\n      }\n\n      // async with promises\n      findAuthor().catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method catch\n      @param {Function} onRejection\n      Useful for tooling.\n      @return {Promise}\n    */\n      'catch': function(onRejection) {\n        return this.then(null, onRejection);\n      }\n    };\n    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\n    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\n      this._instanceConstructor = Constructor;\n      this.promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n      if (Array.isArray(input)) {\n        this._input     = input;\n        this.length     = input.length;\n        this._remaining = input.length;\n\n        this._result = new Array(this.length);\n\n        if (this.length === 0) {\n          lib$es6$promise$$internal$$fulfill(this.promise, this._result);\n        } else {\n          this.length = this.length || 0;\n          this._enumerate();\n          if (this._remaining === 0) {\n            lib$es6$promise$$internal$$fulfill(this.promise, this._result);\n          }\n        }\n      } else {\n        lib$es6$promise$$internal$$reject(this.promise, this._validationError());\n      }\n    }\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {\n      return new Error('Array Methods must be provided an Array');\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {\n      var length  = this.length;\n      var input   = this._input;\n\n      for (var i = 0; this._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n        this._eachEntry(input[i], i);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n      var c = this._instanceConstructor;\n      var resolve = c.resolve;\n\n      if (resolve === lib$es6$promise$promise$resolve$$default) {\n        var then = lib$es6$promise$$internal$$getThen(entry);\n\n        if (then === lib$es6$promise$then$$default &&\n            entry._state !== lib$es6$promise$$internal$$PENDING) {\n          this._settledAt(entry._state, i, entry._result);\n        } else if (typeof then !== 'function') {\n          this._remaining--;\n          this._result[i] = entry;\n        } else if (c === lib$es6$promise$promise$$default) {\n          var promise = new c(lib$es6$promise$$internal$$noop);\n          lib$es6$promise$$internal$$handleMaybeThenable(promise, entry, then);\n          this._willSettleAt(promise, i);\n        } else {\n          this._willSettleAt(new c(function(resolve) { resolve(entry); }), i);\n        }\n      } else {\n        this._willSettleAt(resolve(entry), i);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n      var promise = this.promise;\n\n      if (promise._state === lib$es6$promise$$internal$$PENDING) {\n        this._remaining--;\n\n        if (state === lib$es6$promise$$internal$$REJECTED) {\n          lib$es6$promise$$internal$$reject(promise, value);\n        } else {\n          this._result[i] = value;\n        }\n      }\n\n      if (this._remaining === 0) {\n        lib$es6$promise$$internal$$fulfill(promise, this._result);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n      var enumerator = this;\n\n      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {\n        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\n      }, function(reason) {\n        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\n      });\n    };\n    function lib$es6$promise$polyfill$$polyfill() {\n      var local;\n\n      if (typeof global !== 'undefined') {\n          local = global;\n      } else if (typeof self !== 'undefined') {\n          local = self;\n      } else {\n          try {\n              local = Function('return this')();\n          } catch (e) {\n              throw new Error('polyfill failed because global object is unavailable in this environment');\n          }\n      }\n\n      var P = local.Promise;\n\n      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\n        return;\n      }\n\n      local.Promise = lib$es6$promise$promise$$default;\n    }\n    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\n\n    var lib$es6$promise$umd$$ES6Promise = {\n      'Promise': lib$es6$promise$promise$$default,\n      'polyfill': lib$es6$promise$polyfill$$default\n    };\n\n    /* global define:true module:true window: true */\n    if (typeof define === 'function' && define['amd']) {\n      define(function() { return lib$es6$promise$umd$$ES6Promise; });\n    } else if (typeof module !== 'undefined' && module['exports']) {\n      module['exports'] = lib$es6$promise$umd$$ES6Promise;\n    } else if (typeof this !== 'undefined') {\n      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\n    }\n\n    lib$es6$promise$polyfill$$default();\n}).call(this);\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-promise/dist/es6-promise.js\n ** module id = 1\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/process/browser.js\n ** module id = 2\n ** module chunks = 0\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 3\n ** module chunks = 0\n **/","module.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/amd-define.js\n ** module id = 5\n ** module chunks = 0\n **/","(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var list = this.map[name]\n    if (!list) {\n      list = []\n      this.map[name] = list\n    }\n    list.push(value)\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    var values = this.map[normalizeName(name)]\n    return values ? values[0] : null\n  }\n\n  Headers.prototype.getAll = function(name) {\n    return this.map[normalizeName(name)] || []\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = [normalizeValue(value)]\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n      this.map[name].forEach(function(value) {\n        callback.call(thisArg, value, name, this)\n      }, this)\n    }, this)\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    reader.readAsArrayBuffer(blob)\n    return fileReaderReady(reader)\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    reader.readAsText(blob)\n    return fileReaderReady(reader)\n  }\n\n  var support = {\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob();\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (!body) {\n        this._bodyText = ''\n      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {\n        // Only support ArrayBuffers for POST method.\n        // Receiving ArrayBuffers happens via Blobs, instead.\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n\n      this.text = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return readBlobAsText(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as text')\n        } else {\n          return Promise.resolve(this._bodyText)\n        }\n      }\n    } else {\n      this.text = function() {\n        var rejected = consumed(this)\n        return rejected ? rejected : Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n    if (Request.prototype.isPrototypeOf(input)) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = input\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this)\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function headers(xhr) {\n    var head = new Headers()\n    var pairs = xhr.getAllResponseHeaders().trim().split('\\n')\n    pairs.forEach(function(header) {\n      var split = header.trim().split(':')\n      var key = split.shift().trim()\n      var value = split.join(':').trim()\n      head.append(key, value)\n    })\n    return head\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = options.status\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = options.statusText\n    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers;\n  self.Request = Request;\n  self.Response = Response;\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request\n      if (Request.prototype.isPrototypeOf(input) && !init) {\n        request = input\n      } else {\n        request = new Request(input, init)\n      }\n\n      var xhr = new XMLHttpRequest()\n\n      function responseURL() {\n        if ('responseURL' in xhr) {\n          return xhr.responseURL\n        }\n\n        // Avoid security warnings on getResponseHeader when not allowed by CORS\n        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n          return xhr.getResponseHeader('X-Request-URL')\n        }\n\n        return;\n      }\n\n      xhr.onload = function() {\n        var status = (xhr.status === 1223) ? 204 : xhr.status\n        if (status < 100 || status > 599) {\n          reject(new TypeError('Network request failed'))\n          return\n        }\n        var options = {\n          status: status,\n          statusText: xhr.statusText,\n          headers: headers(xhr),\n          url: responseURL()\n        }\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/whatwg-fetch/fetch.js\n ** module id = 6\n ** module chunks = 0\n **/"],"sourceRoot":""}